第27章 处理流

标准C++库包含用来方便输入和输出的iostream库。
将输入和输出语言分开并使用库来处理输入和输出的优点是更容易使语言独立于平台。流是C++的标准组成部分。
流的主要目的是将从磁盘读取文件或将输入写入控制台屏幕的问题封装起来。创建流后，程序便可使用，流将处理所有的细节。
缓冲技术：数据被写入到流中，而不立刻写入到磁盘中，不断填充流的缓冲区，当缓冲区填满后，一次性将其中的所有数据写入磁盘。
偶尔要在缓冲区未被填满时将数据写入磁盘，称为刷新缓冲区。

C++从面向对象的角度来实现流和缓冲区，使用一系列的类和对象来完成这项任务：
1. streambuf类管理缓冲区，其成员函数提供了填充、清空、刷新和处理缓冲区的其他功能。
2. ios类是输入和输出流类的基类，它有一个成员变量为streambuf对象。
3. istream和ostream类是从ios类派生而来的，用于专门管理输入和输出的行为。
4. iostream是从istream和ostream类派生而来的，提供了向屏幕写入数据的输入和输出方法。
5. fstream类提供了文件的输入和输出功能。

标准I/O对象：包含iostream类的C++程序启动时，将创建并初始化4个对象。  #include <iostream>
cin: 处理来自标准输入设备（键盘）的输入。
cout: 处理到标准输出设备（控制台屏幕）的输出。
cerr: 处理到标准错误设备（控制台屏幕）的非缓冲输出。发送到cerr的任何数据都将立即写入标准错误设备。
clog: 处理输出到标准错误设备（控制台屏幕）的缓冲错误信息，通常被重定向到日志文件。

每种标准流（输入、输出和错误）都可以重定向到其他设备。
重定向指的是将输入或输出发送到不同于默认设备的地方，而管道技术(piping)指的是将一个程序的输出用作另一个程序的输入。
重定向是一种操作系统功能，而不是iostream库的功能。
DOS和Unix的重定向运算符是 <(重定向输入) 和 >(重定向输出)。 Unix提供了更高级的重定向功能。

负责输入的cin是一个全局对象，因为没有在自己的代码中定义它。 重载了提取运算符(>>)：将存放在cin缓冲区中的数据写入到目标变量。
cin重载了接受各种参数的提取运算符，包括int&, short&, long&, double&, float&, char&, char*等。
参数按照引用传递，故cin可以对原始变量进行操作。
cin还能处理字符指针(char*)参数，可创建一个字符缓冲区，并使用cin来填充它。cin自动在字符串末尾加上一个空字符，表示字符串结束。
遇到空格或换行符时，cin认为输入结束。原因是cin能够实现多重复制，多重复值一般会使用空格或换行作为分隔。
>> 的返回值是一个istream对象引用。由于cin本身是istream对象，因此提取操作的返回值可用作下一次提取操作的输入，从而实现级联。

cin的其他成员函数：注是cin对象的成员函数，而非独立的函数。
.get():  //弥补了cin会跳过空白的问题。
1.不接受任何参数，它返回找到的字符值，如果达到文件末尾则返回EOF。（不常用）返回值不是iostream，无法级联。
2.用字符变量作为参数，把输入流中的下一个字符赋给字符变量，返回iostream对象，可以级联。
3.接受3个参数 .get(pCharArray, StreamSize, TermChar); 
参数1是字符数组指针，参数2是要读取的最大字符数加1（读取时自动添加空字符），参数3是结束字符（默认使用'\n'）。
cin>>未处理的内容会被继续保留在缓冲区中。
.getline(pCharArray, StreamSize, TermChar);   //getline()在读取到换行符后将其丢弃，get()将其留在输入缓冲区中。其他功能相同。

有时需要忽略行尾(EOL)或文件尾(EOF)之前的剩余字符，可使用.ignore(n, TermChar); //参数为要忽略的最大字符数和结束字符。
.ignore()用来直接删除缓冲区中的n个字符，知道遇到换行符，然后丢弃换行符，ignore()语句结束。
.peek(); //查看但不提取下一个字符。
.putback();  //将一个字符插入到输入流中。
.peek()和.putback()通常用于分析字符串和其他数据，如编写编译器时。

cout可以通过重载的插入运算符(<<)将字符串，整数和其他数值写入到屏幕，还可对数据进行格式化：对齐，十进制或十六进制书写。
endl写入一个换行符并刷新输出缓冲区。endl调用cout的成员函数flush()，后者输出被缓冲的所有数据，
也可直接调用flush(): cout << flush(); 需要清空输出缓冲区并将其中的内容写入屏幕是，该方法非常方便。
.put();  //用于将单个字符写入输出设备。返回一个ostream引用，因此可以级联。
.write(Test, Size);  //工作原理和插入运算符(<<)相同，参数1是要打印的文本，参数2指定打印其中多少个字符（文本不足会继续读取未知内容）。
输出流包含很多状态标记，用于指定计数方式（十进制或十六进制）、字段宽度和字段填充字符。
状态标记长为1个字节，其中每一位都有特殊含义。每个ostream标记都可以用成员函数和控制符来设置。
输出的默认宽度为刚好能够容纳输出缓冲区中的数字、字符或字符串。
cout.width();  //修改下一个输出字段的宽度，然后字段宽度设置立刻恢复到默认值。
cout.fill();  //修改输出时用于填充字段的字符，默认为空格。设置的填充字符一直有效，直到再次修改为止。
当对象的部分或全部数据成员表示可在程序执行期间修改的条件时，该对象被认为是有状态的。
iostream对象使用标记来记录其状态。可以调用.self()并传递一个预定义的枚举常量来设置这些标记。
这些枚举常量的作用域为iostream类(ios)，因此将其作为self()的参数时，需要采用全限定方式ios::flagname。
要使用标记，必须在程序中包含iostream，要使用需要参数的标记，还必须包含iomanip。

一些iostream设置标记(flagname)：
showpoint     根据精度设置显示小数点和末尾的零
showpos       在正数前面加上正号(+)
left          让输出左对齐
right         让输出右对齐
internal      让符号左对齐并让数值右对齐
scientific    用科学表示法显示浮点数
fixed         以小数点表示法显示浮点数
showbase      在十六进制数前加上Ox，指出这是十六进制值
uppercase     在十六进制和科学表示法中使用大写字母
dec           以十进制方式显示
oct           以八进制方式显示
hex           以十六进制方式显示
使用方法：1.cout.setf(ios::flagname)//需要对标记进行全限定; 2.cout << flagname; //无需对标记进行全限定。两种方法等价。

C++程序还提供了标准C语言I/O库。其中的printf()函数虽然在某些方面比cout使用更加容易，但应该尽量避免使用。
printf()没有提供类型安全性，很容易导致整数和字符的显示混淆。不支持类，必须将类成员逐个传递。
需要包含头文件 #include <stdio.h>   
格式化字符串是用引号括起的文本和转换说明符。所有转换说明符都必须以%打头。
常见的转换说明符：%s, 字符串；%d, 整型；%l, 长整型；%ld, 双精度；%f, 浮点数。
每个转换说明符还可以以浮点方式指定宽度和精度，小数点左边数字表示总宽度，右边表示浮点的精度

cout格式化输出，需要结合使用特殊字符、输出控制符和标记。
特殊字符：
\n:换行符；\r:回车符；\t:制表符；\\:反斜杠；\ddd(八进制数):ASCII字符；\a:振铃。
控制符和cout运算符一起使用，要使用接受参数的控制符，必须在程序中包含iomanip。
不需要包含iomanip就可以使用的控制符：
flush：刷新输出缓冲区；
endl：换行并刷新输出缓冲区；
oct：采用八进制；
dec：采用十进制；
hex：采用十六进制。
需要包含头文件iomanip才能使用的控制符：
setbase(base)：设置计数方式（0为十进制，8为八进制，10为十进制，16为十六进制）；
setw(width)：设置最小输出字段宽度；
setfill(ch)：指定了字段宽度时使用的填充字符；
setprecision(p)：设置浮点数的精度；
setioflags(f)：设置一个或多个ios标记；
resetioflags(f)：重置一个或多个ios标记。

用于读写文件的对象被称为ofstream对象，是从iostream对象中派生出来的。
要开始写入文件，首先必须创建一个ofstream对象，然后将其与磁盘上的文件关联起来。
要使用ofstream对象，必须包含头文件#include <fstream> (内部包含iostream，无需再显示包含)

iostream对象包含报告输入和输出状态的标记：bool函数eof(), bad(), fail(), good().
遇到文件末尾时，eof()返回ture；尝试非法操作时，bad()返回true；bad()返回true或操作失败时，fail()返回true；
三个函数都返回false时，函数good()返回true。

要使用ofstream/ifstream打开文件，声明一个ofstream/ifstream实例，并将该文件名作为参数传递给它。
ofstream fout("a.txt");  //打开a.txt以便进行输出。创建fout流对象进行关联
ifstream fin("a.txt");  //打开a.txt以便进行输入。创建fin流对象进行关联
在完成读写后应关闭文件，确保文件不会受损以及将缓冲区的数据写入磁盘。使用文件流成员函数 fin.close()/fout.close()

ofstream打开文件时的默认行为是，如果文件不存在则创建它，如果文件已经存在则删除其内容。
如果不想采用默认行为打开文件，可以给ofstream类的构造函数提供第2个参数。
ios::app: 附加到已有文件的末尾，而不是删除其内容；
ios::ate: 跳到文件末尾，但可以在文件的任何地方写入数据；
ios::trunc: 默认值，删除已有文件的内容；
ios::nocreate: 如果文件不存在，打开操作失败；
ios::nocreplace: 如果文件已经存在，打开操作失败。

if(!fout)和if(fout.fail())等效。
每次打开文件时都应进行测试以核实文件是否成功打开，应重用已有的ifstream和ofstream对象，使用完fstream对象后应该关闭他们。
不要企图关闭cout和cin或给他们重新赋值。

C++提供了标记ios::binary来帮助区分二进制文件和文本文件。
二进制文件不仅能够存储整数和字符串，还能够存储整个数据结构，可以使用fstream的write()方法一次性写入所有的数据。
如果使用write()写入，可以用read()来读取。这两个函数都接受一个字符指针作为参数，必须将类的地址强制转换为字符指针。
这两个函数的第二个参数是要读写的字符数，可以用sizeof()来确定。
写入的只有类的数据，而不包括方法；读取的也只有数据。 fin.read(); fout.write();

命令行允许在启动程序时给它传递参数，用空格将参数分开。这些参数被称为命令行选项。 SomeProgram Param1 Param2 Param3 ...
每个程序的main()函数默认被传入两个参数：
参数1是整数，指定了命令行参数数目，包括程序名本身，故至少会有1个参数；
参数2是一个字符串指针数组，可将其声明为指向字符指针的指针(char **p)，指向字符数组的指针(char *p[])，字符数组的数组(char a[][]).
参数1的通常名为argc(argument count)，参数2的通常名为argv(argument value)，也可以指定其他名称。
argv[0]是程序名，argv[1]是以字符串表示的程序的第一个参数。

一般情况下，输入输出直接使用插入和提取运算符。特殊需要时（读取含空格的字符串），使用其成员函数。
