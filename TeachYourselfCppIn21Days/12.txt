第12章 多态

单继承出现的问题，如果一个类的特征介于两个基类特征之间，同时具有两个基类的特征，单继承会导致陷入困境。（具体见书中内容）
提升：将所需的函数放到类层次结构较高（基）的位置（虚函数），是解决单继承问题的常用方法，但会破坏类型化，创建出庞大的基类。
避免仅仅为了能够在某些派生类中调用函数而将它提升到不属于它的地方。
向下转换：进行普通的强制指针类型转换来用基类指针赋值新指针，使指针指向派生类对象，从而访问派生类独有的函数。  
dynamic_cast运算符支持向下转换。 失败返回NULL。   向下转换的方法不推荐！      破坏虚函数的多态性。
终极提升：将两个基类的函数提升的共同基类中，使用统一的基类链表，存放派生类所有特征。  本末倒置！

多重继承：从多个类派生出新类。   class DerivedClass : public BaseClass1, public BaseClass2 {};
可以通过虚函数方式覆盖同名函数，新函数可以在函数体内调用另一个其他名的函数。
使用多重继承后，创建BaseClassX指针则可以完全访问派生类的具有BaseClassX属性的内容。

多重继承可能会产生各种重复信息，比如两个基类具有相同的参数和函数，如何避免歧义，具体的使用方法见下面的探讨。
显式调用： Object.baseClassX::function() 指定要选择的函数或数据成员。  
也可以进行函数覆盖，在函数体内部显式调用。  DerivedClass :: func1() { BaseClassX::func1(); }
多重继承的基类是从相同的更高级基类中继承下来的情况，同样应该使用函数覆盖以及在函数体内部显式调用来选择要使用的基类成员。
这种方法称为调用基类的同名方法。
显式地指定祖先类时将带来风险：如果以后在当前类和祖先类直接插入新类，会导致跳过新类直接访问祖先类，可导致意外后果。
上面的继承方法结构图：  VeryBaseClass -----> BaseClass1 -----> NewClass
                        VeryBaseClass -----> BaseClass2 -----|
虽然具有共同的基类，但是在处理的过程中作为两个不同的基类副本进行处理，故访问基类需要指定分支。
虚继承结构图：   VeryBaseClass -----> BaseClass1 -----> NewClass
                              |-----> BaseClass2 -----|
让师祖基类称为两个基类的虚基类，只存在一个共同基类的副本。  使用关键字virtual
通常，类的构造函数只初始化自己的变量及其基类，但虚继承的基类例外，它们由最后的派生类进行初始化。中间类对基类的初始化被忽略。
在调用同名函数时，也无需显式调用属于基类的成员函数，由于虚继承的原因而不会导致歧义。
多重继承会增加调试难度，开发变困难，风险增大。几乎所有用多重继承完成的工作不用也能完成。Java，C#等语言不支持多重继承。

混合类：多重继承和单继承之间的一种折中方案，增加专有功能而不会增加大量方法或数据。  
即通过多重继承的方式，来继承一个功能类，不增加派生类的复杂程度，出现歧义的可能性降低。

break在switch语句中是有作用的，因此会作用于switch；continue在switch语句中是没有用的，因此会作用于switch外面的循环语句。

抽象数据类型（ADT）类为其派生类提供接口，接口表示一种概念而非具体对象。抽象类只能用作其他类的基类，不能创建抽象类的实例。
通过纯虚函数来支持创建抽象类，将虚函数初始化为 函数声明=0； 来声明为纯虚。任何包含纯虚函数的类都是抽象类，不能对其实例化。
纯虚函数表面两点：不要创建这个类的对象，应从其派生；务必覆盖从这个类继承的纯虚函数。
通常不提供抽象基类中纯虚函数的实现，但也可以像正常函数一样进行实现。
可以从抽象类中派生出其他抽象类，将一些继承来的纯虚函数变成非纯虚函数，其他的保留不变。派生抽象类同样不可以实例化。

务必使用抽象类给系列相关类通用的功能提供描述。务必将所有必须覆盖的函数声明为纯虚的。
接口是一种机制，指定了类应实现的方法以及这些方法的特征标。 
C++接口是只包含纯虚函数的抽象基类。继承抽象基类的类必须实现它声明的纯虚函数，并采用指定的特征标。
